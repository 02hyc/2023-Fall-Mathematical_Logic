% This document is compiled using pdfLaTeX
% You can switch XeLaTeX/pdfLaTeX/LaTeX/LuaLaTeX in Settings

\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{amssymb}

\title{再读结构}
\author{211250100 黄琰琛}
\date{\today}

\begin{document}

\newpage
\maketitle
\tableofcontents

\newpage
\section{概述 }
在最近的学习当中，我常常会感到有一些困惑，对于重言蕴含和逻辑蕴含，我刚开始有那么一点分不清楚。但是后来我弄明白了分别，重言蕴含是能够由公理推导而得出的，而逻辑蕴含是在一个模型中，由一组赋值推导而出的。我发觉我不理解的关键，在于没有弄明白模型的问题，于是我再一次将目光放到模型上，希望能够在这次的再学习中，收获一些新的知识。\\

\section{一阶语言的前导内容 }
在重温这部分之前，还是要对一阶语言的一些定义再做一步了解。一阶语言是一组符号的序列，这组符号中包括括号(,),命题联结符号$\neg$和$\rightarrow$，变量和常量，量词符号$\forall$,谓词符号和函数符号。而为了简化句子表达，于是又引入了$\exists$、$\land$、$\lor$符号。表达式是符号的任意有限序列，通常来说，任意符号的排列并没有特殊的意义，当表达式的符号序列具有特殊意义时，称它们为项和合式公式。项的定义是在变量或者常数之前加上函数符号得到的表达式，形如$f\xi_{1}\xi_{2}...\xi_{n}$。原子公式的定义是在项之前加上n元谓词符号得到的表达式，形如$Pt_1t_2...t_n$。而合式公式是由原子公式通过添加否定、蕴含联结词或者加上全称量词而得到的。书上列举了$\neg v_3$，称其不是一个合式公式，原因也十分显然，因为$v_3$部分只是一个变量，而不是一个原子公式。\cite{example_article}\\

\section{结构 }
\subsection{结构的基本定义 }
说完了上述的前导内容，就可以正式接触模型这一概念了。模型，亦是结构，其作用是将一阶逻辑语言翻译成自然语言的句子。一阶语言的结构要说明全称量词的集合是什么，即结构的论域。然后要解释一阶语言中的n元谓词和函数符号，解释清楚这些在结构中所代表的含义。换言之，要建立起一阶语言到自然语言的一一对应关系。一个结构$A$，可以看作是一个函数，$A$为全称量词$\forall$指派一个非空集合$|A|$，即为结构的论域。然后再为每个n元谓词符号$P$指派一个n元关系，$P^A \subseteq |A|^n$。然后为每个常数符号$c$也指派一个论域上的$c^A$。然后再为每个n元函数符号$f$指派一个$|A|$上的n元映射$f^A$，这个映射关系为：$|A|^n \rightarrow |A|$。那么模型中的变量呢？变量是一阶语言中变化的量，往往随着其不同的变化，句子的语义和真假都会发生变化。结构中，会以$|A|$为定义域，为每个变量$v_i$赋值，当在某种赋值条件下，某个一阶语言句子成立，那么这个句子就在这个结构下为真。我们可以举一个简单的例子来说明。比如，有如下句子：
\begin{align*}
    & \exists x \forall y \neg y \in x
\end{align*}
注意到句子中出现的谓词符号是$\in$，于是我们给出这样的结构，为这个谓词符号定义：
\begin{align*}
    & |A| = \text{自然数集，} \\
    & \in^A = \text{使得 m < n 的所有有序对<m,n>组成的集合。}
\end{align*}
于是我们可以将句子翻译为自然语言：
\begin{align*}
    & \text{存在一个自然数，没有比它更小的自然数。}
\end{align*}
这个句子的自然语言翻译显然是正确的，因为正好存在最小的自然数。\\

\subsection{扩充 }
接下来就是对于变量的映射了。变量的映射是由函数$s$来作用的，函数$s$将每个变量都映射到论域$|A|$中。如果某个合式公式为$\phi$,当$\phi$在结构$A$中，以函数$s$赋值的变量语句为真，则称之为$s$满足$\phi$，记作$\models_A \phi[s]$。这是对于每个变量的扩充。变量扩充完了，那项如何扩充呢？在先前的知识中可以知晓，项是在变量或常量前加上函数符号构成的，因此，对于项的扩充，是从变量和常量开始的。我们记项的映射函数为$\overline{s}$，由于项是一个递归的定义，所以$\overline{s}$的定义如下：
\begin{align*}
    & \text{（1）对每一个变量x，}\overline{s}(x)=s(x) \text{这里的s(x)既为之前定义的变量的映射函数。 }  \\
    & \text{（2）对每一个常数符号c， }\overline{s}(c)=c^A \\
    & \text{（3）如果 }t_1,...,t_n\text{是项，且f是一个n元函数符号，则 }\overline{s}(ft_1...t_n)=f^A(\overline{s}(t_1),...,\overline{s}(t_n))
\end{align*}
（3）这句话说明，对于语句中的具有函数符号的项的映射，就是在映射到$|A|$中的变量$\overline{s}(t),...,\overline{t_n}$之前加上映射到$|A|$中的函数符号$f^A$，在结构上亦是一对一的。\\

\subsection{函数集$\overline{h}$ }
对于一个原子公式，其扩充和项的扩充类似，通俗地讲，就是将原句子中的n元谓词符号和n个项全部映射过去。书上还给出了一个函数$\overline{h}$，若公式为$\phi$，那么$\overline{h}(\phi)$为一个函数的集合，这个集合中的函数都是从$\phi$中的变量集合$V$映射到$|A|$上的。书上仅仅作出了如下定义：
\begin{align*}
    & \models_A \phi[s] \text{    iff     } s \in \overline{h}(\phi)
\end{align*}
但是书上对于这个$\overline{h}$并没有说的很清楚。在一开始，我并没有弄懂这部分内容，但后来，我稍微有了一些理解。这里可以通过递归定义函数$\overline{h}$来使得$|A|$以$\phi$满足$s$当且仅当$s \in \overline{h}(\phi)$。
\begin{align*}
    & \text{对于原子公式}\phi = Pt_1...t_n \text{定义 }\overline{h}(\phi) = \{s:V \rightarrow |A|, <\overline{s}(t_1),...,\overline{s}(t_n)\in P^A>\}
\end{align*}
这个集合的前半部分说明这是一个满足从V到|A|的函数的集合，后半部分说明在结构|A|中，这些映射之后的项依然满足映射到|A|中的$P^A$关系。
然后进一步定义$\overline{h}(\phi) = \{s:V \rightarrow |A|, <\overline{s}(t_1),...,\overline{s}(t_n)\notin P^A>\}$。
所以，当$s \in \overline{h}(\neg \phi)$  iff  $s \notin \overline{h}(\phi)$  iff  $\nvDash_A \phi[s]$  iff  $\models_A \neg \phi[s]$。然后进一步定义：$\overline{h}((\phi \rightarrow \psi)) = \overline{h}(\neg \phi)\cup \overline{h}(\psi)$。通俗地解释，就是对于一阶逻辑语言$\phi \rightarrow \psi$而言，要使这个句子为真，则要么是$\phi$为假要么是$\psi$为真。然后定义$\overline{h}(\forall x \phi) = \{s:V \rightarrow |A|, for all d \in |A|, s(x|d) \in \overline{h}(\phi)\}$。所以有$s \in \overline{h}(\forall x\phi)$  iff  对于每一个d$\in |A|$，$s(x|d) \in \overline{h}(\phi)$  iff  对于每一个$d \in |A|$，$\models_A \phi[s(x|d)]$  iff  $\models_A \forall x \phi[s]$。\\

关于结构中的可定义性部分，用我的理解来看就是四个字：看菜做饭。你的结构中本来就定义好的论域、常量、谓词关系和函数，就是你所拥有的食材，你要定义出的新的关系、新的函数就是你要制作的菜品。书上对一些关系的定义写得已经比较清晰了，课后习题中这部分内容的难度也不是很高，所以暂时不多赘述。\\

\subsection{同态和同态定理 }
关于同态这部分内容，我一开始也有些疑惑。主要困惑的点在于书上并没有阐释清楚同态、同构之间的关系，对于子结构我也有一些困惑的点。两个结构$A$和$B$，若他们是同构的，当且仅当存在一个从$|A|$到$|B|$的一一对应关系。而同态，虽然也是一个从$|A|$到$|B|$的关系，但他们并不一定是一一对应的，可能是多对一的。比如自然数集$\mathbb{N}$,它可以将所有的偶数都映射到0，将所有的奇数都映射到1。书上将同态关系定义为了一个函数$h$：$|A| \rightarrow |B|$。对于同态而言，谓词关系和函数要保持一致性，因此这个函数$h$需要保持原有的关系和函数：
\[
\begin{gathered}
    \text{(1) 对 n 元谓词 P 和 } |A| \text{ 中的 n 元组 } <a_1,...,a_n> \text{ 有：} \\
    <a_1,...,a_n> \in P^A \text{ iff } <h(a_1),...,h(a_n)> \in P^B
\end{gathered}
\]

\[
\begin{gathered}
    \text{(2) 对 n 元函数符号 f 和 } |A| \text{ 中的 n 元组 } <a_1,...,a_n> \text{ 有：} \\
    h(f^A(a_1,...,a_n)) = f^B(h(a_1),...,h(a_n))
\end{gathered}
\]

\[
\begin{gathered}
    \text{(3) 对 } |A| \text{ 中的常数符号 } c \text{，有如下关系：} \\
    h(c^A) = c^B.
\end{gathered}
\]
接下来便是同态定理的部分。在最开始上课时，对于部分内容的证明有些云里雾里，所以这次再重点看一下这部分内容。同态定理的内容是说，若$h$是从$|A|$到$|B|$的同态，s是从变量集合$V$到$|A|$的映射函数。
\begin{align*}
    & \text{（1）对每个项t，有}h(\overline{s}(t))=\overline{h \circ s}(t) \\
    & \text{（2）对每个不包含等于符号的无量词的公式 }\alpha \\
    & \models_A \alpha[s] \text{  iff  } \models_B \alpha[h \circ s] \\
    & \text{（3）如果}h\text{是一个一对一的同构，那么在（2）中可以去掉“不包含等于符号”的限制。 } \\
    & \text{（4）如果 }h\text{是 }A\text{到 }B\text{上的同态，那么在（2）中可以去掉“无量词”的限制 }
\end{align*}
对于（1），$\overline{s}(t)$是在$A$中计算，而$\overline{h \circ s}(t)$是在$B$中计算的。接下来对项t进行归纳证明：
\begin{enumerate}
    \item 对变量$x$而言，$h(\overline{s}(x))=h(s(x))=h \circ s(x)=\overline{h \circ s}(x)$这里的第一个等号是因为对于变量x来说的话，$\overline{s}$和$s$的含义是一样的，都是对于变量的扩充。第二个等号的右边就是用函数连接符号将$h(s(x))$写成复合函数的形式，第三个等号加上上划线代表是对变量x使用了项的扩充。
    \item 对常量$c$而言，$h(\overline{s}(c))=h(c^A)=c^B=\overline{h \circ s}(c)$。第一个等号是因为$\overline{s}(c)$是对$c$到$|A|$中的扩充，所以$\overline{s}(c)=c^A$，而$h$是从$|A|$到$|B|$的映射，所以有$h(c^A)=c^B$，所以相当于在$|B|$中计算$\overline{h \circ s}(c)$。
    \item 对拥有函数符号的$fx_1...x_n$而言，$h(\overline{s}(fx_1...x_n))$是先对这个项进行到$|A|$的扩充，然后再使用$h$完成到$|B|$的映射。根据先前的知识，先将其扩充到$|A|$上后得到这样的形式：$h(f^A(\overline{s}(x_1),...,\overline{s}(x_n)))$，然后将映射到$|A|$上的函数符号和项再映射到$|B|$上，得到：$f^B(h(\overline{s}(x_1)),...,h(\overline{s}(x_n)))$，而这相当于$f^B(\overline{h \circ s}(x_1),...,\overline{h \circ s}(x_n))$，也就相当于$\overline{h \circ s}(fx_1...x_n)$，因为$\overline{h \circ s}$就相当于是从项集到$|B|$的映射函数。
\end{enumerate}
对于（2），对于无量词且不包含等号的公式$\alpha$，我们从原子公式开始看起。对于如$Pt$形式的原子公式，有：
\begin{enumerate}
    \item $\models_A Pt[s] \iff \overline{s}(t) \in P^A$ 这一步是显然的，因为若结构$A$要以$s$满足$Pt$，则项$t$在$|A|$中的映射在$|A|$中也满足关系$P^A$。
    \item $\overline{s}(t) \in P^A \iff h(\overline{s}(t)) \in P^B$ 这一步是将在结构$A$中扩充后的项和谓词映射到结构$B$中。
    \item $h(\overline{s}(t)) \in P^B \iff \overline{h \circ s}(t) \in P^B$ 这一步是由（1）得到的，项$t$先向$A$再向$B$的扩充可以由复合函数$\overline{h \circ s}$来一步表示。 
    \item $\overline{h \circ s}(t) \in P^B \iff \models_B Pt[h \circ s]$ 前一步得到的式子的意思是在结构$B$中以函数$h \circ s$满足这个原子公式，故而可以推出最后一步。
\end{enumerate}
而对于合式公式，只是在原子公式的基础上递归的使用$\neg$和$\rightarrow$符号得到的，参考3.3节中的归纳证明过程，这里的证明也是类似的。\\

对于（3），我之前一直的疑问是，等于符号在先前的情况中究竟在什么地方会存在问题呢？于是，再次用严谨的逻辑对$u = t$这个公式（$u$和$t$均为项）进行推理：
\begin{enumerate}
    \item $\models_A u=t[s] \iff \overline{s}(u) = \overline{s}(t)$ 这一步不用过多解释，要以$s$满足$u = t$的话那么$s$和$t$在$A$中的扩充也要相等。
    \item $\overline{s}(u) = \overline{s}(t) \iff h(\overline{s}(u)) = h(\overline{s}(t))$ 问题正是出在这里。从左到右的推理是正确的，但是从右到左就未必。因为对于同态而言，它并不是一个一一对应的关系，它可以是多对一的，因此在上面这个式子从右往左推理的时候，有可能是“从一到多”的一个推理，所以$h(\overline{s}(u)) = h(\overline{s}(t))$并不能正确推理出$\overline{s}(u) = \overline{s}(t)$。但当$h$是一个一一对应的函数，那么这个问题也就不存在了。
\end{enumerate}
对于（4），需要证明将合式公式扩展到包括量词的情况。那么就是要证明，对于$\forall x\phi$，书上说这个式子一定具有性质$\models_B \forall x\phi[h \circ s] \Rightarrow \models_A \forall x \phi[s]$，原因是因为集合$|B|$相较于$|A|$是更大的集合，若在$|B|$中对每个元素都成立，那么在$|A|$中也该对每个元素成立。我一直不太理解为什么$|B|$比$|A|$更大，如果$h$是从$A$到$B$的同态关系的话，按道理来说应该$|A|$比$|B|$更大，因为$h$可以不是一一对应的函数。那这里只能顺着书上所言进行证明。对$|A|$中的每个元素a，有
\begin{enumerate}
    \item $\models_B \forall x\phi[h \circ s] \Rightarrow \models_B \phi[(h \circ s)(x|h(a))]$ 这一步的含义是给函数$h \circ s$赋值每个扩充后的$A$中的元素$h(a)$。
    \item $\models_B \phi[(h \circ s)(x|h(a))] \iff \models_B \phi[(h(s(x|a)))]$ 这一步相当于将复合函数$h \circ s$拆开，先由$s$对$|A|$中每个元素$a$进行扩充，然后再由$h$函数作用上去。
    \item $\models_B \phi[(h(s(x|a)))] \iff \models_A \phi[s(x|a)]$ 这一步是从结构$B$到结构$A$的转换。在上一步中，已经将式子表示成了“在结构$B$中以$s$满足$A$中的式子”的形式，所以能够一步还原到$\models_A \phi[s(x|a)]$这个式子。
\end{enumerate}
\section{总结}
在重新学习了结构这部分内容之后，我对于在原句子和结构中的映射关系有了进一步的理解。但是在重新回顾这段内容的时候，我发现我对最近新学习的演绎计算部分内容和完备性部分又有了疏漏。不禁让我感叹对于基础学科的学习真是任重道远。如果能够在未来投入大量的精力，再回顾一下所学习过的内容，应当是可以有更多的理解和收获的。

\bibliographystyle{plain}
\bibliography{references} 

\end{document}
